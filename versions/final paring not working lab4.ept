const maxSen0:int = 772
const maxSen1:int = 879
const maxSen2:int = 789
const maxSen3:int = 766
const maxSen4:int = 941

const minSen0:int = 290
const minSen1:int = 360
const minSen2:int = 320
const minSen3:int = 310
const minSen4:int = 415

const w0 : int = 14
const w1 : int = 28

const full : int = 8400
const half : int = 4200

--needs more calibration
const lineUpThres :int = 1000
const lineDownThres :int = -1000

const leftThres :int = -800
const rightThres :int = 800

const midThres :int = 400
const maxVal :int = 1024

const lengthOfParking :int = 800
const parkingRadius :int = 500
const hardTurn :int = 320


--get normal values
node getNormal(sen0, sen1, sen2, sen3, sen4: int) returns (b0,b1,b2,b3,b4:int)
	let
		b0=if((sen0-minSen0)<0) then 0 else (1000*(sen0-minSen0))/(maxSen0-minSen0);
		b1=if((sen1-minSen1)<0) then 0 else (1000*(sen1-minSen1))/(maxSen1-minSen1);
		b2=if((sen2-minSen2)<0) then 0 else (1000*(sen2-minSen2))/(maxSen2-minSen2);
		b3=if((sen3-minSen3)<0) then 0 else (1000*(sen3-minSen3))/(maxSen3-minSen3);
		b4=if((sen4-minSen4)<0) then 0 else (1000*(sen4-minSen4))/(maxSen4-minSen4);

	tel
--get normal values for back line
node getNormalBlack(sen0, sen1, sen2, sen3, sen4: int) returns (b0,b1,b2,b3,b4:int)
	let
		b0=if((sen0-minSen0)<0) then 1000 else 1030-(1000*(sen0-minSen0))/(maxSen0-minSen0);
		b1=if((sen1-minSen1)<0) then 1000 else 1030-(1000*(sen1-minSen1))/(maxSen1-minSen1);
		b2=if((sen2-minSen2)<0) then 1000 else 1030-(1000*(sen2-minSen2))/(maxSen2-minSen2);
		b3=if((sen3-minSen3)<0) then 1000 else 1030-(1000*(sen3-minSen3))/(maxSen3-minSen3);
		b4=if((sen4-minSen4)<0) then 1000 else 1030-(1000*(sen4-minSen4))/(maxSen4-minSen4);

	tel
--main node 
node main(sen0, sen1, sen2, sen3, sen4: int; leftIR, rightIR:bool) returns (v_l, v_r, dir,onBlock: int)

var
 last count:int=0;	--for counting square block
 last parkingMode:bool=false;
 last trn:bool=false;
 last leftEmpty:bool=false;
 last rightEmpty:bool=false;
let	
(*
	*****color code*****
	RED 	3
	GREEN	1
	BLUE	
	WHITE 	4
	CYAN	2
	YELLOW	5
	BLANK	0
	*)

	-- ************** while line starts****************
	automaton
		--follows the white line only
		state WhitlLineFollower
		do
		automaton
			state FollowWhiteLine 	
			var b0,b1,b2,b3,b4,x:int;
			do
				onBlock=1;
				(b0,b1,b2,b3,b4)=getNormal(sen0, sen1, sen2, sen3, sen4);
				x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
				v_l=((half-x)*100)/full;
				v_r=((half+x)*100)/full;
				dir=1;
				--check for transtion condition
				trn=if(b0> midThres and (b1 > midThres or b2 < midThres or b3> midThres) and b4> midThres) then true else false;
			until
			 (x< lineDownThres and (b1 > midThres or b2 >midThres or b3> midThres)) then WhiteLeft
			| (x> lineUpThres and (b1 > midThres or b2 >midThres or b3> midThres)) then WhiteRight
			| not  (b1 > midThres or b2 >midThres or b3> midThres) then BackwardWhite
		

			state WhiteLeft 
			var b0,b1,b2,b3,b4,x:int;
			do
				onBlock=2;
				(b0,b1,b2,b3,b4)=getNormal(sen0, sen1, sen2, sen3, sen4);
				x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
				v_l=40;
				v_r=0;
				dir=2;
			until (x > leftThres and (b1 > midThres or b2 >midThres or b3> midThres)) then FollowWhiteLine
			| not  (b1 > midThres or b2 >midThres or b3> midThres) then BackwardWhite


			state WhiteRight 
			var b0,b1,b2,b3,b4,x:int;
			do
				onBlock=5;
				(b0,b1,b2,b3,b4)=getNormal(sen0, sen1, sen2, sen3, sen4);
				x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
				v_l=0;
				v_r=40;
				dir=3;
			until (x< rightThres and (b1 > midThres or b2 >midThres or b3> midThres)) then FollowWhiteLine
			| not  (b1 > midThres or b2 >midThres or b3> midThres) then BackwardWhite

			state BackwardWhite
			var b0,b1,b2,b3,b4,x:int;
			do
				onBlock=3;
				(b0,b1,b2,b3,b4)=getNormal(sen0, sen1, sen2, sen3, sen4);
				x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
				v_l=100;
				v_r=100;
				dir=4;
			until (b1 > midThres or b2 >midThres or b3> midThres) then FollowWhiteLine
			
		end
		unless last trn then InitBlackLine

-- ************** WHITE LINE ENDS ****************

(*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
(*
	*****color code*****
	RED 	3
	GREEN	1
	BLUE	
	WHITE 	4
	CYAN	2
	YELLOW	5
	BLANK	0
	*)

-- ************** BLACK line starts****************
		state InitBlackLine
		var steps:int;
		do
			onBlock=0;
			steps=0->pre(steps)+1;
			v_l=50;
			v_r=50;
			dir=1;
		 until steps<600 then FollowBlackLine

		state FollowBlackLine 	
		var b0,b1,b2,b3,b4,x:int;
		do
			onBlock=0;
			(b0,b1,b2,b3,b4)=getNormalBlack(sen0, sen1, sen2, sen3, sen4);
			x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
			v_l=((half-x)*100)/full;
			v_r=((half+x)*100)/full;
			dir=1;
		until
			 (x< lineDownThres and (b1 > midThres or b2 >midThres or b3> midThres)) then LeftBlack
			| (x> lineUpThres and (b1 > midThres or b2 >midThres or b3> midThres)) then RightBlack
			|((b0 > midThres and b1 >midThres and b2 > midThres) or
			(b0 > midThres and b1 > midThres and b2 >midThres and b3 > midThres) or
			(b1 > midThres and b2 > midThres and b3 >midThres and b4 > midThres) or 
			(b1 > midThres and b2 > midThres and b3 >midThres) or
			(b2 > midThres and b3 > midThres and b4 >midThres)) then Block

		state Block
		do
			onBlock=5;
			v_l=50;
			v_r=50;
			dir=1;
			count=last count +1;
			parkingMode=(count=5);
		until (count=1 or count = 3 or count = 4) then HardLeft
		| (count = 2) then HardRight
		| (count = 5) then ForwardBlack
		| (count > 5) then Stop


		state HardLeft
		var b0,b1,b2,b3,b4,steps:int;
		do
			steps=0->pre(steps)+1;
			onBlock=1;
			(b0,b1,b2,b3,b4)=getNormalBlack(sen0, sen1, sen2, sen3, sen4);
			v_l=50;
			v_r=00;
			dir=1;
		until (steps>hardTurn) then FollowBlackLine

		state HardRight
		var b0,b1,b2,b3,b4,steps:int;
		do
			steps=0->pre(steps)+1;
			onBlock=2;
			(b0,b1,b2,b3,b4)=getNormalBlack(sen0, sen1, sen2, sen3, sen4);
			v_l=00;
			v_r=50;
			dir=1;
		until (steps>hardTurn) then FollowBlackLine

		
		state LeftBlack
		var b0,b1,b2,b3,b4,x:int;
		do
			onBlock=0;
			(b0,b1,b2,b3,b4)=getNormalBlack(sen0, sen1, sen2, sen3, sen4);
			x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
			v_l=40;
			v_r=0;
			dir=2;
		until (x > leftThres and (b1 > midThres or b2 >midThres or b3> midThres)) then FollowBlackLine
		| not  (b1 > midThres or b2 >midThres or b3> midThres) then BackwardBlack


		state RightBlack
		var b0,b1,b2,b3,b4,x:int;
		do
			onBlock=0;
			(b0,b1,b2,b3,b4)=getNormalBlack(sen0, sen1, sen2, sen3, sen4);
			x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
			v_l=0;
			v_r=40;
			dir=3;
		until (x< rightThres and (b1 > midThres or b2 >midThres or b3> midThres)) then FollowBlackLine
		| not  (b1 > midThres or b2 >midThres or b3> midThres) then BackwardBlack

		state BackwardBlack
		var b0,b1,b2,b3,b4,x:int;
		do
			onBlock=3;
			(b0,b1,b2,b3,b4)=getNormalBlack(sen0, sen1, sen2, sen3, sen4);
			x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
			v_l=100;
			v_r=100;
			dir=4;
		until (b1 > midThres or b2 >midThres or b3> midThres) then FollowBlackLine

-- ************** PARKING STARTS ****************

		state ForwardBlack
		var b0,b1,b2,b3,b4,x:int;
		do
			onBlock=3;
			(b0,b1,b2,b3,b4)=getNormalBlack(sen0, sen1, sen2, sen3, sen4);
			x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
			v_l=50;
			v_r=50;
			dir=1;
		until (b1 > midThres or b2 >midThres or b3> midThres) then DetectObsticles
		
(*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
(*
	*****color code*****
	RED 	3
	GREEN	1
	BLUE	
	WHITE 	4
	CYAN	2
	YELLOW	5
	BLANK	0
	*)

--leftIR, rightIR
		
		state DetectObsticles
		var b0,b1,b2,b3,b4,x,steps:int;
		do
			steps=0->pre(steps)+1;
			onBlock=0;
			(b0,b1,b2,b3,b4)=getNormalBlack(sen0, sen1, sen2, sen3, sen4);
			x=(-w1*(b0) -w0*(b1) + 0*(b2) + w0*(b3) +w1*(b4))/(10);
			v_l=((half-x)*100)/full;
			v_r=((half+x)*100)/full;
			dir=1;
			leftEmpty=(last leftEmpty or leftIR);
			rightEmpty=(last rightEmpty or rightIR);
		until
			 (x< lineDownThres and (b1 > midThres or b2 >midThres or b3> midThres)) then LeftBlack
			| (x> lineUpThres and (b1 > midThres or b2 >midThres or b3> midThres)) then RightBlack
			| (steps >lengthOfParking and leftEmpty) then LeftPark
			| (steps >lengthOfParking and rightEmpty) then RightPark
			| (steps >lengthOfParking) then DetectObsticles


		state LeftPark
		var steps:int;
		do
			onBlock=4;
			v_l=50;
			v_r=30;
			dir=4;
			steps=0->pre(steps)+1;
		until steps>parkingRadius then Stop

		state RightPark
		var steps:int;
		do
			onBlock=4;
			v_l=30;
			v_r=50;
			dir=4;
			steps=0->pre(steps)+1;
		until steps>parkingRadius then Stop

		state Stop
		do
			onBlock=4;
			v_l=0;
			v_r=0;
			dir=5;
	end
tel